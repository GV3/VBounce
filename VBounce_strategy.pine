//@version=5
strategy("TrailingVBounce V3", overlay=true, 
   initial_capital=100, 
   default_qty_type=strategy.percent_of_equity, 
   default_qty_value=100,
   calc_on_every_tick=true)

import providencia_trading/WebhookAlertLibrary/3 as webhookAlert    

// FIX: Entry trailing sent, and rise above the entry condition. Currently the webhook is sent, in TView the entry is not done. Fix
 
// =================== Input Parameters ===================
// Date Range
startDate = input.time(timestamp("2024-11-19 00:00"), title="Start Date")
endDate = input.time(timestamp("2024-11-31 23:59"), title="End Date")
withinDateRange = time >= startDate and time <= endDate

// Strategy Parameters
minStrength = input.float(2.2, "Entry: Minimum Drop %", minval=0.1, step=0.02,
   tooltip="Minimum percentage drop from peak to trigger entry")
entryTrailingOffset = input.float(0.5, "Entry: Trailing Offset %", minval=0.1, step=0.02,
   tooltip="How far behind price the trailing stop follows (as % of entry price)")
profitTarget = input.float(2.0, "Exit: Profit Target %", minval=0.1, step=0.02,
   tooltip="Percentage above entry to take profit")
trailStopTarget = input.float(2.0, "Exit: TrailStop Target %", minval=0.1, step=0.02,
   tooltip="Percentage above entry to start the trailing-stop")
trailOffsetPercent = input.float(0.5, "Exit: Trail Offset %", minval=0.1, step=0.02,
   tooltip="How far behind price the trailing stop follows (as % of entry price)")
stopLossPercent = input.float(2.0, "Exit: Stop Loss %", minval=0.1, step=0.02,
   tooltip="Percentage below entry price to exit and mitigate risk")


// Entry Price Settings
var float entryPrice = na
var float profitPrice = na
var float stopPrice = na
var float trailStopTargetPrice = na
var float trailStopOffsetPrice = na
var float entryTrailingOffsetPrice = na
var float entryTrailingDelta = na
var float trail_stop_target_price = na
var float exitTrailingDelta = na
var float exitTrailPrice = na
var float position_size = na


// Webhook state tracking
var bool sendEntryWebhook = false
var bool sendOCOWebhook = false
var bool sendTrailingExitWebhook = false
var bool trailingExitWebhookSent = false
var bool sendEntryUpdateWebhook = false
var bool sendExitUpdateWebhook = false

var bool plotEntryWebhookCall = false
var bool plotOCOWebhookCall = false
var bool plotExitTrailingWebhokCall = false

var entry_order_id = 0
var int oco_order_id = 0
var exit_trail_order_id = 0
var entry_sent_amount = 0
var float lastEntryTrailingPrice = na
var float lastExitTrailingPrice = na

// Message counting
var int entryUpdateCount = 0
var int exitUpdateCount = 0
var int totalMessagesCount = 0
var int positionMessageCount = 0

// Pivot Detection Parameters
pivotLegs = input.int(5, "Pivot Legs", minval=3, maxval=200,
   tooltip="Number of bars to look back/forward for pivot detection")

// =================== State Variables ===================
var float lastPeakPrice = na
var float entryMinDropPrice = na
var float trailOffsetPrice = na
var float stopLossPrice = na
var float lastClosedTrades = 0
var bool positionClosed = false
var bool inEntryTrail = false
var bool inPosition = false

// Update entryPrice when a new position is opened
//if inPosition
  //  entryPrice := strategy.position_avg_price

// Check for position closure and reset state
positionClosed := strategy.closedtrades > lastClosedTrades
if positionClosed
    lastClosedTrades := strategy.closedtrades
    // Reset state
    entryPrice := na
    stopLossPrice := na
    profitPrice := na
    trail_stop_target_price := na
    inPosition := false
    inEntryTrail := false
    entry_order_id := 0
    oco_order_id := 0
    exit_trail_order_id := 0
    trailingExitWebhookSent := false
    // Reset message counters
    entryUpdateCount := 0
    exitUpdateCount := 0
    positionMessageCount := 0

// Update inPosition variable
// inPosition := strategy.position_size > 0

// =================== Functions ===================
percentFromHigh(currentPrice, highPrice) =>
    ((highPrice - currentPrice) / highPrice) * 100

// Converts percentage values to point values based on the entry price and minimum tick size
percentToPoints(percent) =>
    (na(strategy.position_avg_price) ? close : strategy.position_avg_price) * percent / 100 / syminfo.mintick

// Converts percentage values to price values based on the entry price
percentToPrice(percent) =>
    (na(strategy.position_avg_price) ? close : strategy.position_avg_price) * percent / 100

// =================== Pivot Detection Logic ===================
pivotHigh = high[pivotLegs] == ta.highest(high, 2 * pivotLegs + 1)
pivotLow = low[pivotLegs] == ta.lowest(low, 2 * pivotLegs + 1)

// =================== Position Management ===================
// Update peak price on new pivot high
if pivotHigh and withinDateRange
    lastPeakPrice := high[pivotLegs]

// Monitor for exit trailing updates
if inPosition and close >= trail_stop_target_price
    exitTrailPrice := close - exitTrailingDelta
    if exitTrailPrice != nz(lastExitTrailingPrice)
        sendExitUpdateWebhook := true
        lastExitTrailingPrice := exitTrailPrice

    if not trailingExitWebhookSent
        sendTrailingExitWebhook := true

// Monitor for entry conditions
entryCondition = not na(lastPeakPrice) and withinDateRange and
   percentFromHigh(close, lastPeakPrice) >= minStrength

// Track trailing entry logic
if inEntryTrail or (entryCondition and not inPosition)
    // Mock the TrailingStop in TradingView (TView does not support entry/buy of type TrailingStop) 
    if not inEntryTrail
        entryTrailingOffsetPrice := close * (1 + entryTrailingOffset / 100)
        entryTrailingDelta := close * (entryTrailingOffset / 100)
        inEntryTrail := true
        position_size := (strategy.initial_capital + strategy.netprofit)/entryTrailingOffsetPrice
        lastEntryTrailingPrice := entryTrailingOffsetPrice
        
        // Flag to send the initial limit order
        sendEntryWebhook := true
        
    else
        // Update trailing price to follow the lowest price during the trail
        entryTrailingOffsetPrice := math.min(entryTrailingOffsetPrice[1], close * (1 + entryTrailingOffset / 100))
        
        // Flag to update limit order price if changed
        if entryTrailingOffsetPrice != lastEntryTrailingPrice
            sendEntryUpdateWebhook := true
            lastEntryTrailingPrice := entryTrailingOffsetPrice
            // strategy.entry("VBounce", strategy.long, qty = position_size, limit = entryTrailingOffsetPrice)
        
        // Trigger entry when price crosses the trailing offset price upward
        if entryTrailingOffsetPrice > 0 and close >= entryTrailingOffsetPrice
            strategy.entry("VBounce", strategy.long, qty = position_size)
            inEntryTrail := false  // Reset trail tracking
            inPosition := true     // Set position flag immediately

            entryPrice := entryTrailingOffsetPrice
            profitPrice := entryPrice * (1 + profitTarget/100)
            stopLossPrice := entryPrice * (1 - stopLossPercent/100)

            strategy.exit("Exit", "VBounce",
               limit=profitPrice,
               stop=stopLossPrice, 
               trail_points=percentToPoints(trailStopTarget), // Activate trail at profit target
               trail_offset=percentToPoints(trailOffsetPercent) // Trail follows at offset %
               )

            // Calculate the trailing stop target price based on entry price and trailing offset
            if na(trail_stop_target_price)
                trail_stop_target_price := entryPrice * (1 + trailStopTarget / 100)
                exitTrailingDelta := trail_stop_target_price * (trailOffsetPercent/100)
                lastExitTrailingPrice := na

            // Flag to send the OCO order, once the trailing stop executes (aprox.) We are mocking it
            sendOCOWebhook := true

// Alerts Configuration - Bot Webhook 

// Define variables
strategy_name = "TrailingVBounce"
symbol = syminfo.ticker
action = "_define_"
float price = 0
float quantity = 0
float trailing_delta = 0
order_type = "_define_"
var jsonMessage = '{"txt":"msg"}'

// Alert Configuration - Bot Webhook format
// Initial buy limit order (mock trailing stop)
if sendEntryWebhook 
    action := 'buy'
    order_type := 'stop_limit'
    // Quantity is (initial capital + profit)/entry_trailStop_price
    // Remember the quantity is the amount of Contracts (not USD)
    quantity := position_size
    jsonMessage := '{"strategy": "' + strategy_name + '"' +
      ', "symbol": "' + symbol + '"' +
      ', "action": "' + action + '"' +
      ', "quantity": ' + str.tostring(quantity, '#.###') +
      ', "price": ' + str.tostring(entryTrailingOffsetPrice) +
      ', "price_aux_limit": ' + str.tostring(entryTrailingOffsetPrice) +
      ', "order_type": "' + order_type + '"' +
      '}'
    entry_order_id := webhookAlert.sendMessage(jsonMessage)
    entry_sent_amount := entry_sent_amount + 1
    positionMessageCount := positionMessageCount + 1
    totalMessagesCount := totalMessagesCount + 1
    // Update flags
    plotEntryWebhookCall := true
    sendEntryWebhook := false

// Update entry limit price
if sendEntryUpdateWebhook
    jsonMessage := '{"strategy": "' + strategy_name + '"' +
      ', "client_order_id": ' + str.tostring(entry_order_id) +
      ', "price": ' + str.tostring(entryTrailingOffsetPrice) +
      ', "price_aux_limit": ' + str.tostring(entryTrailingOffsetPrice) +
      '}'
    webhookAlert.sendMessage(jsonMessage)
    sendEntryUpdateWebhook := false

// Create OCO order
if sendOCOWebhook
    action := 'sell'
    order_type := 'oco'
    quantity := position_size
    jsonMessage := '{"strategy": "' + strategy_name + '"' +
     ', "symbol": "' + symbol + '"' +
     ', "action": "' + action + '"' +       
     ', "price": '+ str.tostring(profitPrice) +
     ', "price_oco_stop": ' + str.tostring(stopLossPrice) +
     ', "quantity": '+ str.tostring(quantity, '#.###') +
     ', "order_type": "'+ order_type + '"' +
     '}'
    oco_order_id := webhookAlert.sendMessage(jsonMessage)
    positionMessageCount := positionMessageCount + 1 
    totalMessagesCount := totalMessagesCount + 1
    // Update flags
    plotOCOWebhookCall := true
    sendOCOWebhook := false
    
// Send Exit Limit (mock trailing stop)
if sendTrailingExitWebhook
   // Cancel OCO orders and send limit order atomically va Multi-op endpoint
    // Create a new unique order ID for the exit Trail order
    if exit_trail_order_id == 0
        exit_trail_order_id := math.round(time * 10 / 1000) * 10
             
    jsonMessage := '{' +
     '"strategy": "' + strategy_name + '"' +
     '"action": "multi",' +
     '"operations": [' +
       '{' +
         '"group_id": ' + str.tostring(oco_order_id) + 
         '"type": "cancel_multi"' +
       '},' +
       '{' +
         '"type": "submit",' +
         '"strategy": "' + strategy_name + '"' +
         '"symbol": "' + symbol + '"' +
         '"action": "sell",' +
         '"amount": '+ str.tostring(quantity, '#.###') +
         '"price": ' + str.tostring(exitTrailPrice) +
         '"order_type": "limit",' +
         '"client_order_id": ' + str.tostring(exit_trail_order_id) + 
       '}' + 
     ']'+
     '}'
   
    positionMessageCount := positionMessageCount + 1  // 1 new order
    totalMessagesCount := totalMessagesCount + 1
    // Update flags
    plotExitTrailingWebhokCall := true
    sendTrailingExitWebhook := false
    trailingExitWebhookSent := true

// Update exit limit price
if sendExitUpdateWebhook
    jsonMessage := '{"strategy": "' + strategy_name + '"' +
       ', "client_order_id": ' + str.tostring(exit_trail_order_id) +
       ', "price": ' + str.tostring(lastExitTrailingPrice) +
       '}'
    webhookAlert.sendMessage(jsonMessage)
    sendExitUpdateWebhook := false

// =================== Plotting ===================
// Plot pivot points
plotshape(pivotHigh and withinDateRange, title="Pivot High", style=shape.triangledown, 
   location=location.abovebar, color=color.new(color.yellow, 90), size=size.tiny, offset=-pivotLegs)
   
plotshape(pivotLow and withinDateRange, title="Pivot Low", style=shape.triangleup, 
   location=location.belowbar, color=color.new(color.white, 90), size=size.tiny, offset=-pivotLegs)

// Plot ALL potential entry points (when price drops 3% from any peak)
//plotshape(not na(lastPeakPrice) and percentFromHigh(close, lastPeakPrice) >= minStrength,
//   title="Price Drop 3%", style=shape.circle, location=location.belowbar,
//   color=color.new(color.blue, 0), size=size.tiny)

// Plot actual Webhookcalls points
plotshape(plotEntryWebhookCall, title="Entry Webhook call", style=shape.triangleup,
   location=location.belowbar, color=color.new(color.green, 0), size=size.small)
plotEntryWebhookCall := false

plotshape(plotOCOWebhookCall, title="OCO Webhook call", style=shape.triangleup,
   location=location.belowbar, color=color.new(color.blue, 0), size=size.tiny)
plotOCOWebhookCall := false

plotshape(plotExitTrailingWebhokCall, title="Exit Trailing Webhook call", style=shape.triangleup,
   location=location.belowbar, color=color.new(color.red, 0), size=size.tiny)
plotExitTrailingWebhokCall := false

// Plots for visualizing TP & SL levels
//plot(percentToPoints(profitTarget), style = plot.style_linebr, color = color.red, trackprice = true)
//plot(profitPrice, style = plot.style_linebr, color = color.blue)
//plot(trailOffsetPrice, style = plot.style_linebr, color = color.yellow)

msg = "Status:"
msg := msg + 
   "\n =================== State ===================" +
   "\n Entry Condition: " + str.tostring(entryCondition) +
   "\n In Entry Trail: " + str.tostring(inEntryTrail) +
   "\n In Position: " + str.tostring(inPosition) +
   "\n Position Closed: " + str.tostring(positionClosed) +
   "\n -------------------------------------------" +
   "\n ================= Entry Stage ==============" +
   "\n Last Peak Price: " + str.tostring(lastPeakPrice) +
   "\n Entry TrailStop Price: " + str.tostring(entryTrailingOffsetPrice) +
   "\n Current Limit Price: " + str.tostring(lastEntryTrailingPrice) +
   "\n Trailing Delta: " + str.tostring(entryTrailingDelta) +
   "\n Position Size: " + str.tostring(position_size, '#.###') + " contracts" +
   "\n Entry Price: " + str.tostring(entryPrice) +
   "\n -------------------------------------------" +
   "\n ================= Exit Stage ===============" +
   "\n Take Profit: " + str.tostring(profitPrice) +
   "\n Stop Loss: " + str.tostring(stopLossPrice) +
   "\n Trail Target: " + str.tostring(trail_stop_target_price) +
   "\n Current Limit Price: " + str.tostring(lastExitTrailingPrice) +
   "\n Trailing Delta: " + str.tostring(exitTrailingDelta) +
   "\n -------------------------------------------" +
   "\n ================ Messages =================" +
   "\n Entry Updates: " + str.tostring(entryUpdateCount) +
   "\n Exit Updates: " + str.tostring(exitUpdateCount) +
   "\n Current Position Total: " + str.tostring(positionMessageCount) +
   "\n All-Time Total: " + str.tostring(totalMessagesCount) +
   "\n -------------------------------------------" +
   "\n ================ Orders ===================" +
   "\n Entry Order ID: " + str.tostring(entry_order_id) +
   "\n Entry Messages Sent: " + str.tostring(entry_sent_amount) +
   "\n OCO Order ID: " + str.tostring(oco_order_id) +
   "\n Exit Trail Order ID: " + str.tostring(exit_trail_order_id) +    
   "\n -------------------------------------------" +
   "\n ================ Capital =================" +
   "\n Initial Capital: " + str.tostring(strategy.initial_capital) +
   "\n Current Equity: " + str.tostring(strategy.equity) +
   "\n ===========================================" +
   "\n Last Message:" + 
   "\n " + jsonMessage +
   "\n ===========================================" +
   "\n TrailingVBounce V3.3.1 "

// Set text color based on current bar
textColor = (bar_index == ta.highest(bar_index, 1)) ? color.white : color.gray

// Calculate the price range
priceRange = ta.highest(high, 200) - ta.lowest(low, 200)
topPosition = ta.lowest(low, 200) - (priceRange * 0.1)

// Update or create the label
var label myLabel = na
if (bar_index == 0)
    myLabel := label.new(x=bar_index - 10, y=topPosition, text=msg, style=label.style_label_up, color=color.new(color.blue, 90), textcolor=textColor, size=size.normal)
else
    label.set_xy(myLabel, bar_index - 10, topPosition)
    label.set_text(myLabel, msg)
    label.set_textcolor(myLabel, textColor)
